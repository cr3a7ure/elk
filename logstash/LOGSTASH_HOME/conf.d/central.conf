input {
	beats {
		port => 5044
	#	type => "access.feature"
       		client_inactivity_timeout => 3600
	}

	#file {
	#	path => "C:/Users/waeber/Desktop/test_logs/*.log"
	#	start_position => "beginning"
	#	sincedb_path => "C:/Users/waeber/Desktop/sincedb.txt"
	#}
}

filter {
	# orders the input data into general fields. 
	grok {
	    patterns_dir => ["/etc/logstash/conf.d/patterns"]
		#patterns_dir => ["C:/Users/waeber/elk/logstash/LOGSTASH_HOME/conf.d/patterns"]
	    match => { "message" => "%{SWISSBIBLOG}" }
	}
	
	# reformats the date and removes the old timestamp field.
	date {
		match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
		target => "@timestamp"
		remove_field => [ "timestamp" ]
    }

	# removes events without useragent. These are all actions not taken by users.
	if ([useragent] =~ /-/) {
       	drop{}
	}
	
	# filters out a few types of request which happen a lot but add no information for visual effects etc.
    if ([message] =~ /(the\+art\+of\+computer\+programming)|(\/themes)|(^"-" - - )|(GET \/apple-touch-icon)|(GET \/favicon.ico)|(GET \/\?lng)|(GET \/" 200 19698 "-" "-")|(\/Cover\/Show)/) {
       	drop{}
    }
	
	# remove fields with just a '-' in it. This way kibana can more easily deal with not existing fields.
	if ([responsesize] =~ /-/){
		mutate {
			remove_field => [ "responsesize" ]
		}
	}
	
	if ([referrer] =~ /-/) {
		mutate {
			remove_field => [ "referrer" ]
		}
	}

	if ([forwardip] =~ /-/) {
		mutate {
			remove_field => [ "forwardip" ]
		}
	}
	
	# sometimes two forward ips are in a request. these are separated for further processing. This way both ips are available in an array and can be used in kibana.
	if ([session] =~ /-/) {
		mutate {
			remove_field => [ "session" ]
		}
	}
	
	# some fields have two ips separated by comma.
	# we pack them into an array and process both. 
	# unknown why this is the case.
	if ([forwardip] =~ /,/) {
		mutate {
			gsub => [ "forwardip", " ", "" ]
			split => { "forwardip" => "," }
		}
	}

	# Looks up the ip in the database and creates fields with associated data. Location is a geo-point hash which alows kibana to plot the data into maps.
	if ([forwardip] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
		geoip {
			source => "forwardip"
			#database => "C:/Users/waeber/Desktop/logstash-5.3.3/vendor/bundle/jruby/1.9/gems/logstash-filter-geoip-4.0.4-java/vendor/GeoLite2-City.mmdb"
			database => "/etc/logstash/geoip/GeoLite2-City.mmdb"

			target => "geoip"
			fields => ["city_name", "country_name", "location"]
			add_tag => [ "apache-geoip" ]
			tag_on_failure => ["_geoip_lookup_failure"]
		}
	}
	
	# searches for holding requests and extracts the holding identifiers.
	# and stores the value in a new field 'library_code'
	if ([request] =~ /\/Holdings\/\d*\/.+/) {
		grok {
			id => "request_grok"
			match => { "request" => "\/Holdings\/\d*\/%{WORD:library_code}" }
		}	
	}
	
	# looks up the library code in dictionary and puts the name into library_name
	# requires manual update if new libraries are added to swissbib
	if ([library_code]) {
		translate {
			field => library_code
			destination => "library_name"
			dictionary_path => "/etc/logstash/conf.d/libraries/member_library_dictionary.yaml"
			exact => true
		}
	}
	
	# analyzes the user agent of the request and creates a user field
	# 
	# https://www.elastic.co/guide/en/logstash/current/plugins-filters-useragent.html
	# https://de.wikipedia.org/wiki/User_Agent
	useragent {
		source => [ "useragent" ]
		target => [ "userdata" ]
	}
	
	# remove some fields whith information we don't really need
	# the add_field is required as there is a documented bug which makes the removal impossible otherwise.
	# leaves userdata.device, userdata.name & userdata.os_name.
	mutate {
		add_field => { "[userdata][os_major]" => "os_major_version" }
		remove_field => ["[userdata][os_major]", "[userdata][os_minor]", "[userdata][os]", "[userdata][patch]", "[userdata][major]", "[userdata][minor]", "[userdata][build]" ]
	}
	
	if ([requestparam] =~ /\&limit=\d{1,2}\&/) {
		grok {
			id => "limit_grok"
			match => { "requestparam" => "\.*?\&limit=%{NUMBER:page_limit}\&.*" }
		}
	}


	
	# detects and translates hosts
    if ([host] =~ /sb-uvf1|sb-uvf2|sb-uvf3/) {
		mutate {
			add_field => {"sourcetype" => "presentationgreen" } 
		}
    } 

    if ([host] =~ /sb-uvf9|sb-uvf10|sb-uvf11/) {
		mutate {
			add_field => {"sourcetype" => "presentationbb" } 
		}
    } 

    if ([host] =~ /sb-uvf5/) {
		mutate {
			add_field => {"sourcetype" => "presentationjus" } 
		}
    } 

	# detects some bots
    if ([message] =~ /Googlebot|bingbot|Slurp|YandexBot|AhrefsBot|MegaIndex\.ru|BLEXBot|Baiduspider|SemrushBot/) {
		grok {
			match => { "message" => "(?<bot>Googlebot|bingbot|Slurp|YandexBot|AhrefsBot|MegaIndex\.ru|BLEXBot|Baiduspider|SemrushBot)" }
		}
    }
}

output {

    if ([sourcetype] == "presentationgreen") {
		elasticsearch { 
			hosts => ["sb-uesl1.swissbib.unibas.ch:8080"]
			#template => "C:/Users/waeber/elk/logstash/LOGSTASH_HOME/conf.d/es_template/apache_template.json"
			template => "/etc/logstash/conf.d/es_template/apache_template.json"

			template_name => "apache_template"
			template_overwrite => true
			index => "swissbib-green-%{+YYYY}"
			document_type => "logs"
		}
    }

    if ([sourcetype] == "presentationbb") {
		elasticsearch { 
			hosts => ["sb-uesl1.swissbib.unibas.ch:8080"]
			#template => "C:/Users/waeber/elk/logstash/LOGSTASH_HOME/conf.d/es_template/apache_template.json"
			template => "/etc/logstash/conf.d/es_template/apache_template.json"
			template_name => "apache_template"
			template_overwrite => true
			index => "swissbib-bb-%{+YYYY}"
			document_type => "logs"
		}
    }

    if ([sourcetype] == "presentationjus") {
		elasticsearch { 
			hosts => ["sb-uesl1.swissbib.unibas.ch:8080"]
			#template => "C:/Users/waeber/elk/logstash/LOGSTASH_HOME/conf.d/es_template/apache_template.json"
			template => "/etc/logstash/conf.d/es_template/apache_template.json"
			template_name => "apache_template"
			template_overwrite => true
			index => "swissbib-jus-%{+YYYY}"
			document_type => "logs"
		}
    }
}
